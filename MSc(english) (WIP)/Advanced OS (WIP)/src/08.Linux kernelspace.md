# Linux kernelspace

Effective kernel development necessitates a solid grasp of hardware functionalities and efficient, direct interaction with device registers. 
In the context of kernel development, functions are often declared as `static` to limit their scope and visibility: useful for encapsulation and to avoid name collisions in larger projects, such as the Linux kernel.

## Accessing Peripheral Registers

### Request and Release I/O Regions

```c
struct resource *request_region(unsigned base_addr, unsigned size, const char *name);
void release_region(unsigned base_addr, unsigned size);
```

- **Purpose**: Reserve and release I/O port regions to ensure exclusive access by your driver.
- **Usage**: Typically used during module initialization and cleanup.

### Reading and Writing to I/O Ports

```c
unsigned char inb(unsigned int addr);
unsigned short inw(unsigned int addr);
unsigned int inl(unsigned int addr);
void outb(unsigned char val, unsigned int addr);
void outw(unsigned short val, unsigned int addr);
void outl(unsigned int val, unsigned int addr);
```
- **Purpose**: Read from and write to hardware I/O ports.
- **Usage**: Used within interrupt handlers or other kernel functions to interact with hardware.

## Handling Interrupts

### Request and Free IRQs

```c
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);
void free_irq(unsigned int irq, void *dev_id);
```
- **Purpose**: Register and unregister interrupt handlers.
- **Usage**: Request IRQ during module initialization and free it during cleanup.

### Example Usage
```c
static irqreturn_t uart_interrupt_handler(int irq, void *dev_id) {
    // Interrupt handler code
    return IRQ_HANDLED;
}

static int __init my_module_init(void) {
    if (request_irq(UART_IRQ, uart_interrupt_handler, 0, "my_uart_driver", NULL)) {
        printk(KERN_ERR "Failed to request IRQ\n");
        return -EBUSY;
    }
    // Other initialization code
    return 0;
}

static void __exit my_module_exit(void) {
    free_irq(UART_IRQ, NULL);
    // Other cleanup code
}
```

## Thread Concurrency in Linux Kernel 

### Mutexes
```c
struct mutex my_mutex;
void mutex_init(mutex *m);
void mutex_lock(mutex *m);
void mutex_unlock(mutex *m);
```
- **Purpose**: Ensure mutual exclusion in kernel threads.
- **Usage**: Used in thread functions to protect shared data.

## Interrupt Concurrency

### Spinlocks
```c
struct spinlock_t my_spinlock;
void spin_lock_init(spinlock_t *spinlock);
void spin_lock(spinlock_t *spinlock);
void spin_unlock(spinlock_t *spinlock);
void spin_lock_irq(spinlock_t *spinlock);
void spin_unlock_irq(spinlock_t *spinlock);
```
- **Purpose**: Ensure mutual exclusion in interrupt handlers and other critical sections.
- **Usage**: Used in both interrupt handlers and normal kernel code.

## Waiting for Interrupts

### Wait Queues
```c
struct wait_queue_head_t my_wait_queue;
void init_waitqueue_head(wait_queue_head_t *waiting);
void wait_event_interruptible_lock_irq(wait_queue_head_t *waiting, condition, spinlock_t *spinlock);
void wake_up(wait_queue_head_t *waiting);
```
- **Purpose**: Block a process until a condition becomes true.
- **Usage**: Used in scenarios where a process needs to wait for an interrupt or other events.

## Filesystem Operations

### Read and Write Operations

```c
ssize_t my_driver_write(struct file *f, const char __user *buf, size_t size, loff_t *o);
ssize_t my_driver_read(struct file *f, char __user *buf, size_t size, loff_t *o);
```
- **Purpose**: Handle read and write operations from user space.
- **Usage**: Implement custom read/write operations for your driver.

### Registering and Unregistering Character Devices

```c
struct file_operations my_driver_fops = {
    .owner = THIS_MODULE,
    .write = my_driver_write,
    .read = my_driver_read,
};

int major = register_chrdev(0, "my_driver", &my_driver_fops);
unregister_chrdev(major, "my_driver");
```
- **Purpose**: Register and unregister character devices.
- **Usage**: Set up and tear down device file operations for your driver.

## Copying Data Between User Space and Kernel Space


- `copy_to_user` and `copy_from_user` are used for safely copying data across this boundary. They ensure that the pointers provided by user space are valid and that the copying process doesn't lead to buffer overflows or access violations.
- `copy_to_user` copies data from the kernel space to user space, while `copy_from_user` copies data from user space to kernel space.

`copy_from_user` and `copy_to_user` are designed to handle the security checks necessary to prevent user space from accessing or corrupting kernel memory. Always use these functions instead of `memcpy` when dealing with user space memory in the kernel.

- When a user space application needs to send data to a kernel module (e.g., a device driver), it passes a pointer to the data buffer in user space.


**Invalid Memory Access**: User space memory addresses may not be valid in the context of kernel space. The operating system uses memory protection mechanisms to isolate user space and kernel space. These protections prevent user processes from accessing kernel memory and vice versa.


```c
unsigned copy_from_user(void *to, const void __user *from, unsigned n);
unsigned copy_to_user(void __user *to, const void *from, unsigned n);
```

- **Purpose**: Safely copy data between user space and kernel space.
- **Usage**: Used in read/write operations to transfer data.

## Example Exercise Structure

### Interrupt example 

Key Steps

1. Compute correct registers memory addresses 
2. **Request I/O region and IRQ**.
3. **Implement interrupt handler** to count received bytes.

