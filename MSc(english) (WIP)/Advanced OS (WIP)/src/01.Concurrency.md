
# Concurrency 

## User space concurrency 

Concurrency is when a program consists of activities that can overlap in execution. A program can be characterized by two properties:

- **Safety**: nothing bad happens.
- **Liveness**: makes progress and is not just stuck. 

Regarding concurrency we can highlights these aspects:

- **Deadlock** between tasks: due to mutual exclusion, hold-and-wait, no preemption, and circular wait conditions.
- **Priority inversion** is a scheduling scenario where a high priority task is delayed by a lower priority task due to locking. The bad concurrency model inverts the priority model

### Guarantee user space concurrency

To avoid deadlocks and prioritize safety and liveness in concurrent programs:

- Use resource allocation policies that ensure safe acquisition of resources
- Detect and recover from deadlocks
- Use resource allocation policies that prevent deadlocks from occurring
- Implement prevention and detection strategies

There three techniques to solve this issue:

1) Highest Locker Priority (HLP)
2) Priority Inheritance (PIP)
3) Priority Ceiling (PCP)


## Kernel concurrency 

Kernel concurrency refers to the management and synchronization of multiple threads in the kernel space. Having a deep understanding of kernel concurrency allows to utilize lockless algorithms, fine-grained locking, and specialized synchronization primitives provided by the kernel.
There are multiple sources of concurrency in the kernel:

- **interrupts**: can occur asynchronously at almost any time, interrupting the currently executing code in kernel mode.
- **Kernel preemption**: multiple threads in the kernel can share the same resources
- **Multiple processors kernel concurrency**: kernel code must be able to simultaneously run on multiple processors and regularization of the access to resources is necessary to permit to be SMP-safe.
### Kernel preemption 

Scheduling can be called during some kernel mode code execution in specific **preemption points**:

- **`TIF_NEED_RESCHED` flag** forces the process to switch at the end of interrupt/exception handling, if set in the thread descriptor. 
- **Planned process switch** if a task in the kernel explicitly blocks and calls `schedule()`.

How? 

- `preempt_count`variable is used to ensure a safe context switch , called , that keeps track of the preemptions: the value is initially set at 0 and increases by 1 in two scenarios: 
	1. When a process acquires a lock in its critical section.
	2. When an interrupt occurs.
- As long as `preempt_count > 0` the kernel cannot switch.

**Atomic context** refers to the places where it is not sate to call the scheduler and switch to a different thread like for example when the kernel is running an interrupt, is holding a spinning lock or in others "unsafe situations" like when modifying the per-cpu structures.

**Spinning locks** continuously poll the lock until it becomes available while a sleeping lock (semaphores in Linux) (more overhead) waits until it is notified that the lock is available. A spinlock is generally useful when critical section length are small  and the waiting time is short, otherwise it becomes inefficient.
On SMP machines the spinlock is the basic ingredient.
Variants of spinning locks are: 

- **Readwrite locks**: distinguish between readers and writers, where multiple readers can access an object simultaneously, whereas only one writer is allowed at a time. 
- **Seqlocks**: to prevent starvation of writers, a counter starting from 0 is used to track the number of writers holding the lock. Each writer increments the counter both at locking/unlocking phase. The counter permits to determine if any writes are currently in progress: if the counter is even, it means that no writes are taking place. Conversely, if the counter is odd, it indicates that a write is currently holding the lock. Similarly readers check the counter when trying to lock: if the counter is odd, it means busy wait. If even the reader does the work but before releasing, it checks if the counter changed (in case it does again the work).
- **Lockdep**: lockdep enables to report deadlocks before they actually occur in the kernel, which is equally impacted by the problem of deadlocks. When `CONFIG_PROVE_LOCKING`, **lockdep** detects violations of locking rules keeping track of locking sequences, when spinlocks are acquired in interrupt handlers and also in process context and stuff like this.

### Multiple processors kernel concurrency: MCS lock

A Mellor-Crummey and Scott (**MCS**) lock is a type of lock that is used to implement mutual exclusion in a multi-threaded program. A MCS lock consists of a queue of nodes (threads) waiting to acquire the lock. When a thread attempts to acquire the lock, it adds itself to the queue and spins (repeatedly checks the lock status) until it becomes the head of the queue. Once a thread becomes the head of the queue, it can acquire the lock and proceed with its critical section of code.

They are generally considered to be more efficient than other types of locks, such as spin locks and mutexes. 

