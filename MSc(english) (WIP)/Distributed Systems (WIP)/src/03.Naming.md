
## Naming

In a DS, there are various entities such as hosts, processes, threads, disks, and files. These entities need to be referred to by other entities. Names are used to refer to these entities and can be considered as a way for entities to reference each other. Additionally, entities are typically accessed through access points, which are essentially addresses or names used to access them.

It's needed a mechanism to map names into addresses. 

A name can be classified into global/locals but also human-friendly/machine-friendly. 

Regarding this Name Resolution refers to the process of obtaining the address of a valid access point of an entity having its name (DNS maps domain names to hosts and RMI registry are examples). 

The way name resolution is performed depends on the nature of the naming schema employed: 

### Flat naming 

In **Flat naming** there isn't a particular structure in the name. 
It can be implemented with: 

- **Simple solutions**: designed for small scale envs
		- **broadcast**
		- **multicast**
		- **forwarding pointers**: a particular technique to solve mobile nodes which consists in leaving reference to the next location at the previous location
- **Home-based approaches**: A single home node is used to track the location of the mobile unit. The assumption is that the home node is stable and can be replicated for reliability. However, this approach adds an extra step and increases latency. This system lacks geographical scalability, as the entity may be physically close to the client but still relies on the home node.
- **DHT**: DHT is a good solution for flat naming because it's strongly distributed. An example is **Chord** which is a protocol and algorithm for a peer-to-peer distributed hash table.
- **Hierarchical approaches**: Network divided into domains where a root domain covers entire network and leaf domains represent LANs or cells. Each domain has an associated directory node that keeps track of the entities in that domain. The Hierarchical lookup may start anywhere (where client resides), if the not found, forward lookup to parent. If entry found, forward lookup to child until a leaf holding the concrete entry is found. This solution doesn't scale very well. 

#### Chord 

Now let's go into the detail of Chord. 
Nodes and keys are organized in a logical ring. Search is performed linearly if na√Øve: the item with key $k$ is stored by the node with the smallest $id \ge k$ (the successor of node $k$). 

If managed smarter, search is **logarithmic**: the item with key $k$ is stored by the largest node in the successor column where there are all nodes $(id + 2^i)$-th node for incrementing $i$. 

The logarithmic version is called "finger table". 

The idea of the routing table is to let you go as far as possible, as close as possible to the node without overshooting.

The number of bits used by the DHT corresponds to the number of rows in the routing tables.

In most cases, there is no computer connected with a given ID. This is because the search space is typically much larger than the current number of computers connected, allowing for the addition of new nodes.

Obviously the first step is always to search in the local space of the node and only later following the algorithm.







### Structured naming

Names are organized in a name space. DNS is the best known example of system which use structured naming. The namespace can be partitioned into logical layers: 

- global level 
- administrational level 
- managerial level


| Item | Global | Administrational | Managerial |
| :--- | :--- | :--- | :--- |
| Geographical scale of network | Worldwide | Organization | Department |
| Total number of nodes | Few | Many | $\begin{array}{l}\text { Vast } \\\text { numbers }\end{array}$ |
| Responsiveness to lookups | Seconds | Milliseconds | Immediate |
| Update propagation | Lazy | Immediate | Immediate |
| Number of replicas | Many | None or few | None |
| Is client-side caching applied? | Yes | Yes | Sometimes |


#### Name resolution techniques 

Two main techniques of name resolution are **iterative** and **recursive**:

- Iterative ns involves resolving the name by first asking the root and then its sub-nodes to find the responsible resource. Pros of this technique include:
	- reduced communication costs
	- more effective caching along the resolution chain. 
	However, it may lead to higher demand on each name server.
- Recursive ns starts from the root and then recursively forwards the request to its sub-nodes. This technique does not involve caching, which can result in slower lookups. Additionally, each name server in this resolution method is responsible for a single request, increasing demand on each server.


![](images/75f6caf8c6f664b4d62ea66e14ac8365.png)


DNS name space is organized as a hierarchically rooted tree with separate authorities for each domain.
Each name server is responsible for a specific zone. Global servers are mirrored and queries are routed by IP anycast (not broadcast, it's a variant of unicast where is used only a node, chosen by the network among the nodes).
Caching and replication are widely used, with stability in the global and administrative layers while more frequent changes in the managerial layer.

While moving a host within the same domain only requires updating the domain name servers, if i's moved to a different domain, DNS servers can provide the new IP address or create a symbolic link to the new location but may affect lookup efficiency.


### Attribute-based naming

The idea of attribute-based names is to add artificial information into the name. Attribute based naming systems are usually called directory services and they are usually implemented by using DBMS. 

LDAP is the dominant protocol used for directory services. LDAP directories consist in a collection of directory entries which is called Directory Information Base (DIB). 
Each record in the DIB has a unique name composed of naming attributes. 
In large-scale directories, the DIB is typically partitioned according to the Directory Information Tree (DIT) structure and: 

- Servers are known as Directory Service Agents (DSA)
- Clients as Directory User Agents (DUA)


## Removing unreferenced entities

- In some cases, objects need to be removed from the system since unreachable from any other node.
- This is typically done by creating a graph
- Automatic garbage collection is common in conventional systems.
- Distribution of systems complicates the process due to lack of global knowledge and network failures.


Different approaches: 

- **Reference counting**: Every object keeps track of the number of references it has. When an object is created, its reference counter is set to 1. When a reference is no longer needed, the counter decreases. One problem with this approach is ensuring reliability and preventing race conditions when passing references between processes.
- **Weighted reference counting**: Tries to circumvent the race condition by communicating only counter decrements Requires an additional counter Removing a reference subtracts the proxy partial counter from the total counter of the skeleton: when the total and partial weights become equal garbage collection happens. The only problem with this is that only a fixed number of references can be created.

Weighted reference counting is a technique that addresses race conditions by only communicating counter decrements. It involves adding an additional counter.

In this approach, when a reference is removed, the proxy partial counter is subtracted from the total counter of the skeleton. Garbage collection is triggered when the total and partial weights become equal.

So creating a proxy doesn't require you to reform the skeleton, you only reform the skeleton when you destroy the proxy. Okay,

However, a limitation of weighted reference counting is that only a fixed number of references can be created.

Still exists some techniques like "asking more weigths form the proxy" or "create a recursive weigthed reference counting" to solve this problem.


Remember that here the advantage over a "standard counting" is that creating a proxy doesn't require you to reform the skeleton. You only reform the skeleton when you destroy the proxy. 

- **Reference listing**: it is used a list to track the identities of the proxies. Easier maintenance in the event of network failures since "pinging" clients to check if they are alive is possible. However, race conditions can still occur when copying references.

- **Mark-and-sweep**: Tries to identifies disconnected groups of objects from the root set using a graph and turning the problem into a "search/graph exploration". There are issues such as the requirement for a stable reachability graph and potential scalability problems.
